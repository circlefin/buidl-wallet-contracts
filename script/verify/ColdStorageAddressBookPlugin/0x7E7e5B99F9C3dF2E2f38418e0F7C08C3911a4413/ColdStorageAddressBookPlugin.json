{"language":"Solidity","sources":{"src/msca/6900/v0.7/plugins/v1_0_0/addressbook/ColdStorageAddressBookPlugin.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\nimport {\n    PLUGIN_AUTHOR,\n    PLUGIN_VERSION_1,\n    SIG_VALIDATION_FAILED,\n    SIG_VALIDATION_SUCCEEDED\n} from \"../../../../../../common/Constants.sol\";\nimport {CastLib} from \"../../../../../../libs/CastLib.sol\";\nimport {RecipientAddressLib} from \"../../../../../../libs/RecipientAddressLib.sol\";\nimport {Unsupported} from \"../../../../shared/common/Errors.sol\";\nimport {\n    ManifestAssociatedFunction,\n    ManifestAssociatedFunctionType,\n    ManifestFunction,\n    PluginManifest,\n    PluginMetadata,\n    SelectorPermission\n} from \"../../../common/PluginManifest.sol\";\nimport {Call} from \"../../../common/Structs.sol\";\nimport {IPlugin} from \"../../../interfaces/IPlugin.sol\";\nimport {IStandardExecutor} from \"../../../interfaces/IStandardExecutor.sol\";\nimport {BasePlugin} from \"../../BasePlugin.sol\";\nimport {IAddressBookPlugin} from \"./IAddressBookPlugin.sol\";\nimport {PackedUserOperation} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\n\nimport {\n    AssociatedLinkedListSet,\n    AssociatedLinkedListSetLib\n} from \"@modular-account-libs/libraries/AssociatedLinkedListSetLib.sol\";\n\n/**\n * @dev This plugin serves as an enhanced version of the AddressBookPlugin, incorporating additional limitations on\n * target contracts.\n *      It necessitates verification of ownership through either native semi-MSCA mechanisms or a dedicated plugin\n * function\n *      designed for full MSCA compliance.\n *      1. For semi-MSCA with native validation such as SingleOwnerMSCA, please provide the follow dependency during\n * installation\n *          a. FunctionReference(mscaAddr, uint8(SingleOwnerMSCA.FunctionId.NATIVE_RUNTIME_VALIDATION_OWNER_OR_SELF))\n *          b. FunctionReference(mscaAddr, uint8(SingleOwnerMSCA.FunctionId.NATIVE_USER_OP_VALIDATION_OWNER))\n *\n *      2. For full MSCA with plugin validation such as UpgradableMSCA, please provide the follow dependency during\n * installation\n *          a. FunctionReference(singleOwnerPluginAddr,\n * uint8(ISingleOwnerPlugin.FunctionId.RUNTIME_VALIDATION_OWNER_OR_SELF))\n *          b. FunctionReference(singleOwnerPluginAddr, uint8(ISingleOwnerPlugin.FunctionId.USER_OP_VALIDATION_OWNER))\n *      Both runtime and userOp validations should be covered.\n *\n *      Design:\n *      1. For token transfers, verify support for the function selector; if unsupported, reject the transaction. This\n * validation is bypassed for native transfers.\n *      2. Extract the recipient's address from the transaction's calldata for token transfers, or from the target for\n * native transfers.\n *      3. If the recipient's address is not specified (== address(0)) within the calldata, reject the transaction.\n *      4. Validate the recipient against the on-chain address book; validate the target if value > 0 && recipient !=\n * target; unauthorized addresses result in transaction\n * rejection.\n *      5. If the recipient is authorized, proceed with the transaction.\n */\ncontract ColdStorageAddressBookPlugin is BasePlugin, IAddressBookPlugin {\n    using AssociatedLinkedListSetLib for AssociatedLinkedListSet;\n    using RecipientAddressLib for bytes;\n\n    string public constant NAME = \"Cold Storage Address Book Plugin\";\n    string internal constant ADDRESS_BOOK_READ = \"AddressBookRead\";\n    string internal constant ADDRESS_BOOK_WRITE = \"AddressBookWrite\";\n    uint256 internal constant _OWNER_RUNTIME_VALIDATION_DEPENDENCY_INDEX = 0;\n    uint256 internal constant _OWNER_USER_OP_VALIDATION_DEPENDENCY_INDEX = 1;\n    // act as a safety mechanism if a plugin is blocking uninstallation\n    uint16 internal constant _MAX_RECIPIENTS_TO_DELETE = 5000;\n    // use MSCA's address as associated address to pass 4337 storage rule check\n    AssociatedLinkedListSet internal _allowedRecipients;\n\n    // function id to plugin itself\n    enum FunctionId {\n        PRE_USER_OP_VALIDATION_HOOK_EXECUTE_ADDRESS_BOOK,\n        PRE_RUNTIME_VALIDATION_HOOK_EXECUTE_ADDRESS_BOOK,\n        PRE_USER_OP_VALIDATION_HOOK_EXECUTE_BATCH_ADDRESS_BOOK,\n        PRE_RUNTIME_VALIDATION_HOOK_EXECUTE_BATCH_ADDRESS_BOOK\n    }\n\n    /**\n     * @dev Add allowed recipient.\n     * Can only be called by the current msg.sender.\n     */\n    function addAllowedRecipients(address[] calldata recipients) external {\n        _addRecipients(recipients);\n        emit AllowedAddressesAdded(msg.sender, recipients);\n    }\n\n    /**\n     * @dev Remove allowed recipient.\n     * Can only be called by the current msg.sender.\n     */\n    function removeAllowedRecipients(address[] calldata recipients) external {\n        uint256 length = recipients.length;\n        for (uint256 i = 0; i < length; ++i) {\n            if (!_allowedRecipients.tryRemove(msg.sender, CastLib.toSetValue(recipients[i]))) {\n                revert FailToRemoveRecipient(msg.sender, recipients[i]);\n            }\n        }\n        emit AllowedAddressesRemoved(msg.sender, recipients);\n    }\n\n    /**\n     * @dev Returns the allowed addresses of the current MSCA.\n     */\n    function getAllowedRecipients(address account) external view returns (address[] memory) {\n        return _getAllowedRecipients(account);\n    }\n\n    /// @inheritdoc BasePlugin\n    function onInstall(bytes calldata data) external virtual override {\n        // if the caller does not provide any recipients during installation, the caller\n        // must call addAllowedRecipients first before calling any other execution functions\n        if (data.length != 0) {\n            address[] memory recipients = abi.decode(data, (address[]));\n            _addRecipients(recipients);\n            emit AllowedAddressesAdded(msg.sender, recipients);\n        }\n    }\n\n    /// @inheritdoc BasePlugin\n    function onUninstall(bytes calldata data) external override {\n        (data);\n        address[] memory recipients = _getAllowedRecipients(msg.sender);\n        // clearing up plugin storage is optional for the caller;\n        // callers should call removeAllowedRecipients in batches if they\n        // need to clear plugin storage\n        if (recipients.length < _MAX_RECIPIENTS_TO_DELETE) {\n            _allowedRecipients.clear(msg.sender);\n            emit AllowedAddressesRemoved(msg.sender, recipients);\n        } else {\n            emit AllowedAddressesNotRemoved(msg.sender);\n        }\n    }\n\n    /// @inheritdoc BasePlugin\n    function preUserOpValidationHook(uint8 functionId, PackedUserOperation calldata userOp, bytes32 userOpHash)\n        external\n        view\n        override\n        returns (uint256 validationData)\n    {\n        (userOpHash);\n        if (functionId == uint8(FunctionId.PRE_USER_OP_VALIDATION_HOOK_EXECUTE_ADDRESS_BOOK)) {\n            // This functionality is exclusively compatible with the IStandardExecutor.execute as delineated in the\n            // pluginManifest.\n            // It is incompatible with alternate execution functions, owing to the specific decoding logic employed\n            // here.\n            // calldata length has already been checked in caller\n            (address target, uint256 targetValue, bytes memory targetData) =\n                abi.decode(userOp.callData[4:], (address, uint256, bytes));\n            if (!_isRecipientAllowed(_getTargetOrRecipient(target, targetValue, targetData))) {\n                return SIG_VALIDATION_FAILED;\n            }\n            return SIG_VALIDATION_SUCCEEDED;\n        } else if (functionId == uint8(FunctionId.PRE_USER_OP_VALIDATION_HOOK_EXECUTE_BATCH_ADDRESS_BOOK)) {\n            // This functionality is exclusively compatible with the IStandardExecutor.executeBatch as delineated in the\n            // pluginManifest.\n            // It is incompatible with alternate execution functions, owing to the specific decoding logic employed\n            // here.\n            Call[] memory calls = abi.decode(userOp.callData[4:], (Call[]));\n            uint256 length = calls.length;\n            for (uint256 i = 0; i < length; ++i) {\n                if (!_isRecipientAllowed(_getTargetOrRecipient(calls[i].target, calls[i].value, calls[i].data))) {\n                    return SIG_VALIDATION_FAILED;\n                }\n            }\n            return SIG_VALIDATION_SUCCEEDED;\n        }\n        revert Unsupported();\n    }\n\n    /// @inheritdoc BasePlugin\n    function preRuntimeValidationHook(uint8 functionId, address sender, uint256 value, bytes calldata data)\n        external\n        view\n        override\n    {\n        (value);\n        if (functionId == uint8(FunctionId.PRE_RUNTIME_VALIDATION_HOOK_EXECUTE_ADDRESS_BOOK)) {\n            // This functionality is exclusively compatible with the IStandardExecutor.execute as delineated in the\n            // pluginManifest.\n            // It is incompatible with alternate execution functions, owing to the specific decoding logic employed\n            // here.\n            (address target, uint256 targetValue, bytes memory targetData) =\n                abi.decode(data[4:], (address, uint256, bytes));\n            address recipient = _getTargetOrRecipient(target, targetValue, targetData);\n            if (!_isRecipientAllowed(recipient)) {\n                revert UnauthorizedRecipient(sender, recipient);\n            }\n            return;\n        } else if (functionId == uint8(FunctionId.PRE_RUNTIME_VALIDATION_HOOK_EXECUTE_BATCH_ADDRESS_BOOK)) {\n            // This functionality is exclusively compatible with the IStandardExecutor.executeBatch as delineated in the\n            // pluginManifest.\n            // It is incompatible with alternate execution functions, owing to the specific decoding logic employed\n            // here.\n            Call[] memory calls = abi.decode(data[4:], (Call[]));\n            uint256 length = calls.length;\n            for (uint256 i = 0; i < length; ++i) {\n                address recipient = _getTargetOrRecipient(calls[i].target, calls[i].value, calls[i].data);\n                if (!_isRecipientAllowed(recipient)) {\n                    revert UnauthorizedRecipient(sender, recipient);\n                }\n            }\n            return;\n        }\n        revert Unsupported();\n    }\n\n    /// @dev Upon initial installation of this plugin without designating approved recipients, it is critical to utilize\n    /// addAllowedRecipients()\n    /// before making use of the execute() function. It is advisable against embedding the addAllowedRecipients()\n    /// function within the calldata destined for execute(),\n    /// due to execute() being protected by specific hooks associated with this plugin. Additionally, it should be noted\n    /// that when addAllowedRecipients()\n    /// is accessed through the MSCA fallback function, it does not trigger these hooks.\n    function pluginManifest() external pure virtual override returns (PluginManifest memory) {\n        PluginManifest memory manifest;\n        manifest.executionFunctions = new bytes4[](3);\n        manifest.executionFunctions[0] = this.addAllowedRecipients.selector;\n        manifest.executionFunctions[1] = this.removeAllowedRecipients.selector;\n        manifest.executionFunctions[2] = this.getAllowedRecipients.selector;\n\n        manifest.preUserOpValidationHooks = new ManifestAssociatedFunction[](2);\n        manifest.preUserOpValidationHooks[0] = ManifestAssociatedFunction({\n            executionSelector: IStandardExecutor.execute.selector,\n            associatedFunction: ManifestFunction({\n                functionType: ManifestAssociatedFunctionType.SELF,\n                functionId: uint8(FunctionId.PRE_USER_OP_VALIDATION_HOOK_EXECUTE_ADDRESS_BOOK),\n                dependencyIndex: 0\n            })\n        });\n        manifest.preUserOpValidationHooks[1] = ManifestAssociatedFunction({\n            executionSelector: IStandardExecutor.executeBatch.selector,\n            associatedFunction: ManifestFunction({\n                functionType: ManifestAssociatedFunctionType.SELF,\n                functionId: uint8(FunctionId.PRE_USER_OP_VALIDATION_HOOK_EXECUTE_BATCH_ADDRESS_BOOK),\n                dependencyIndex: 0\n            })\n        });\n\n        manifest.preRuntimeValidationHooks = new ManifestAssociatedFunction[](2);\n        manifest.preRuntimeValidationHooks[0] = ManifestAssociatedFunction({\n            executionSelector: IStandardExecutor.execute.selector,\n            associatedFunction: ManifestFunction({\n                functionType: ManifestAssociatedFunctionType.SELF,\n                functionId: uint8(FunctionId.PRE_RUNTIME_VALIDATION_HOOK_EXECUTE_ADDRESS_BOOK),\n                dependencyIndex: 0\n            })\n        });\n        manifest.preRuntimeValidationHooks[1] = ManifestAssociatedFunction({\n            executionSelector: IStandardExecutor.executeBatch.selector,\n            associatedFunction: ManifestFunction({\n                functionType: ManifestAssociatedFunctionType.SELF,\n                functionId: uint8(FunctionId.PRE_RUNTIME_VALIDATION_HOOK_EXECUTE_BATCH_ADDRESS_BOOK),\n                dependencyIndex: 0\n            })\n        });\n\n        manifest.dependencyInterfaceIds = new bytes4[](2);\n        // fallback validation functions if MSCA doesn't have native ones\n        manifest.dependencyInterfaceIds[_OWNER_RUNTIME_VALIDATION_DEPENDENCY_INDEX] = type(IPlugin).interfaceId;\n        manifest.dependencyInterfaceIds[_OWNER_USER_OP_VALIDATION_DEPENDENCY_INDEX] = type(IPlugin).interfaceId;\n        ManifestFunction memory ownerUserOpValidationFunction = ManifestFunction({\n            functionType: ManifestAssociatedFunctionType.DEPENDENCY,\n            functionId: 0, // unused for dependency\n            dependencyIndex: _OWNER_USER_OP_VALIDATION_DEPENDENCY_INDEX\n        });\n        manifest.userOpValidationFunctions = new ManifestAssociatedFunction[](2);\n        manifest.userOpValidationFunctions[0] = ManifestAssociatedFunction({\n            executionSelector: this.addAllowedRecipients.selector,\n            associatedFunction: ownerUserOpValidationFunction\n        });\n        manifest.userOpValidationFunctions[1] = ManifestAssociatedFunction({\n            executionSelector: this.removeAllowedRecipients.selector,\n            associatedFunction: ownerUserOpValidationFunction\n        });\n\n        ManifestFunction memory ownerRuntimeValidationFunction = ManifestFunction({\n            functionType: ManifestAssociatedFunctionType.DEPENDENCY,\n            functionId: 0, // unused for dependency\n            dependencyIndex: _OWNER_RUNTIME_VALIDATION_DEPENDENCY_INDEX\n        });\n        ManifestFunction memory runtimeAlwaysAllowAssociatedFunction = ManifestFunction({\n            functionType: ManifestAssociatedFunctionType.RUNTIME_VALIDATION_ALWAYS_ALLOW,\n            functionId: 0,\n            dependencyIndex: 0\n        });\n        manifest.runtimeValidationFunctions = new ManifestAssociatedFunction[](3);\n        manifest.runtimeValidationFunctions[0] = ManifestAssociatedFunction({\n            executionSelector: this.addAllowedRecipients.selector,\n            associatedFunction: ownerRuntimeValidationFunction\n        });\n        manifest.runtimeValidationFunctions[1] = ManifestAssociatedFunction({\n            executionSelector: this.removeAllowedRecipients.selector,\n            associatedFunction: ownerRuntimeValidationFunction\n        });\n        manifest.runtimeValidationFunctions[2] = ManifestAssociatedFunction({\n            executionSelector: this.getAllowedRecipients.selector,\n            associatedFunction: runtimeAlwaysAllowAssociatedFunction\n        });\n\n        manifest.interfaceIds = new bytes4[](1);\n        manifest.interfaceIds[0] = type(IAddressBookPlugin).interfaceId;\n        return manifest;\n    }\n\n    /// @inheritdoc BasePlugin\n    function pluginMetadata() external pure virtual override returns (PluginMetadata memory) {\n        PluginMetadata memory metadata;\n        metadata.name = NAME;\n        metadata.version = PLUGIN_VERSION_1;\n        metadata.author = PLUGIN_AUTHOR;\n\n        // Permission descriptions\n        metadata.permissionDescriptors = new SelectorPermission[](3);\n        metadata.permissionDescriptors[0] = SelectorPermission({\n            functionSelector: this.addAllowedRecipients.selector,\n            permissionDescription: ADDRESS_BOOK_WRITE\n        });\n        metadata.permissionDescriptors[1] = SelectorPermission({\n            functionSelector: this.removeAllowedRecipients.selector,\n            permissionDescription: ADDRESS_BOOK_WRITE\n        });\n        metadata.permissionDescriptors[2] = SelectorPermission({\n            functionSelector: this.getAllowedRecipients.selector,\n            permissionDescription: ADDRESS_BOOK_READ\n        });\n        return metadata;\n    }\n\n    /// @inheritdoc BasePlugin\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IAddressBookPlugin).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _addRecipients(address[] memory recipientsToAdd) internal {\n        uint256 length = recipientsToAdd.length;\n        for (uint256 i = 0; i < length; ++i) {\n            if (!_allowedRecipients.tryAdd(msg.sender, CastLib.toSetValue(recipientsToAdd[i]))) {\n                revert FailToAddRecipient(msg.sender, recipientsToAdd[i]);\n            }\n        }\n    }\n\n    function _isRecipientAllowed(address recipient) internal view returns (bool) {\n        return _allowedRecipients.contains(msg.sender, CastLib.toSetValue(recipient));\n    }\n\n    function _getAllowedRecipients(address account) internal view returns (address[] memory) {\n        return CastLib.toAddressArray(_allowedRecipients.getAll(account));\n    }\n\n    /// @dev We do not permit sending native assets to a token contract while simultaneously interacting with it.\n    function _getTargetOrRecipient(address target, uint256 value, bytes memory data) internal view returns (address) {\n        if (value != 0) {\n            // for native asset transfers, we require the calldata to be empty\n            if (data.length != 0) {\n                revert CallDataIsNotEmpty(msg.sender, target, value, data);\n            }\n            if (target == address(0)) {\n                // we do not allow sending native assets to address(0)\n                revert UnauthorizedRecipient(msg.sender, target);\n            }\n            return target;\n        } else {\n            // for token calls, we require that the target address contains code\n            if (target.code.length == 0) {\n                revert InvalidTargetCodeLength(msg.sender, target, value, data);\n            }\n            // the helper function will first check if the function selector is supported\n            address recipient = data.getERC20TokenRecipient();\n            if (recipient == address(0)) {\n                recipient = data.getERC1155TokenRecipient();\n            }\n            if (recipient == address(0)) {\n                recipient = data.getERC721TokenRecipient();\n            }\n            if (recipient == address(0)) {\n                revert UnauthorizedRecipient(msg.sender, recipient);\n            }\n            return recipient;\n        }\n    }\n}\n"},"src/common/Constants.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\n// ERC4337 constants\n\n// return value in case of signature failure, with no time-range.\n// equivalent to _packValidationData(true,0,0);\nuint256 constant SIG_VALIDATION_FAILED = 1;\nuint256 constant SIG_VALIDATION_SUCCEEDED = 0;\n\n// sentinel values\n// any values less than or equal to this will not be allowed in storage\nbytes21 constant SENTINEL_BYTES21 = bytes21(0);\nbytes23 constant SENTINEL_BYTES23 = bytes23(0);\nbytes4 constant SENTINEL_BYTES4 = bytes4(0);\nbytes32 constant SENTINEL_BYTES32 = bytes32(0);\n\n// empty or unset function reference\n// we don't store the empty function reference\nbytes21 constant EMPTY_FUNCTION_REFERENCE = bytes21(0);\n\n// wallet constants\nstring constant WALLET_AUTHOR = \"Circle Internet Financial\";\nstring constant WALLET_VERSION_1 = \"1.0.0\";\n\n// plugin constants\nstring constant PLUGIN_AUTHOR = \"Circle Internet Financial\";\nstring constant PLUGIN_VERSION_1 = \"1.0.0\";\n\n// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\nbytes4 constant EIP1271_VALID_SIGNATURE = 0x1626ba7e;\nbytes4 constant EIP1271_INVALID_SIGNATURE = 0xffffffff;\n\n// keccak256('')\nbytes32 constant EMPTY_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\nuint256 constant ZERO = 0;\n\nbytes32 constant ZERO_BYTES32 = bytes32(0);\nbytes24 constant EMPTY_MODULE_ENTITY = bytes24(0);\n"},"src/libs/CastLib.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\nimport {SetValue} from \"@modular-account-libs/libraries/Constants.sol\";\n\n/// @title Cast Library\n/// @author Alchemy\n/// @notice Library for various data type conversions. Forked from Alchemy's CastLib with modifications.\nlibrary CastLib {\n    /// @dev Input array is not verified. If used with non address type array input, return data will be incorrect.\n    function toAddressArray(SetValue[] memory values) internal pure returns (address[] memory addresses) {\n        bytes32[] memory valuesBytes;\n\n        assembly (\"memory-safe\") {\n            valuesBytes := values\n        }\n\n        uint256 length = values.length;\n        for (uint256 i = 0; i < length; ++i) {\n            valuesBytes[i] >>= 96;\n        }\n\n        assembly (\"memory-safe\") {\n            addresses := valuesBytes\n        }\n\n        return addresses;\n    }\n\n    function toSetValue(address value) internal pure returns (SetValue) {\n        return SetValue.wrap(bytes30(bytes20(value)));\n    }\n}\n"},"src/libs/RecipientAddressLib.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/**\n * @dev Decode the recipient of a token (ERC20, ERC1155 and ERC721) contract call.\n *      In order to use abi.decode to decode the data after the selector, we would need to copy each byte from\n *      the original array to the sliced array expensively because slicing bytes memory array is not as easy as\n *      slicing calldata in Solidity.\n *      Instead we use inline assembly to mload the recipient directly, which is safe because we've checked the\n *      the length of the bytes array.\n */\nlibrary RecipientAddressLib {\n    bytes4 internal constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\"));\n    bytes4 internal constant ERC721_SAFE_TRANSFER_FROM_WITH_BYTES =\n        bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\"));\n    bytes4 internal constant ERC20_INCREASE_ALLOWANCE = bytes4(keccak256(\"increaseAllowance(address,uint256)\"));\n    bytes4 internal constant ERC20_DECREASE_ALLOWANCE = bytes4(keccak256(\"decreaseAllowance(address,uint256)\"));\n    uint256 internal constant TRANSFER_OR_APPROVE_MIN_LEN = 68;\n    uint256 internal constant TRANSFER_FROM_MIN_LEN = 100;\n    uint256 internal constant TRANSFER_FROM_WITHOUT_AMOUNT_WITH_BYTES_MIN_LEN = 164;\n    uint256 internal constant TRANSFER_FROM_WITH_BYTES_MIN_LEN = 196;\n    uint256 internal constant BATCH_TRANSFER_FROM_WITH_BYTES_MIN_LEN = 260;\n    uint256 internal constant TRANSFER_OR_APPROVE_RECIPIENT_OFFSET = 36;\n    uint256 internal constant TRANSFER_FROM_RECIPIENT_OFFSET = 68;\n\n    /// @notice Decode the recipient of a token.\n    /// @dev This only supports the following **standard** ERC20 functions:\n    /// - transfer(address,uint256)\n    /// - approve(address,uint256)\n    /// - transferFrom(address,address,uint256)\n    /// @param data The calldata of the transaction.\n    /// @return The recipient of the token being sent. Zero address if the call is unsupported.\n    function getERC20TokenRecipient(bytes memory data) internal pure returns (address) {\n        bytes4 selector = bytes4(data);\n        if (\n            selector == IERC20.transfer.selector || selector == IERC20.approve.selector\n                || selector == ERC20_INCREASE_ALLOWANCE || selector == ERC20_DECREASE_ALLOWANCE\n        ) {\n            // 68 bytes (4 selector + 32 address + 32 amount)\n            if (data.length < TRANSFER_OR_APPROVE_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector.\n            return getRecipient(data, TRANSFER_OR_APPROVE_RECIPIENT_OFFSET);\n        } else if (selector == IERC20.transferFrom.selector) {\n            // 100 bytes (4 selector + 32 address + 32 address + 32 amount)\n            if (data.length < TRANSFER_FROM_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector, and 32 for the from address.\n            return getRecipient(data, TRANSFER_FROM_RECIPIENT_OFFSET);\n        }\n        return address(0);\n    }\n\n    /// @notice Decode the recipient of a token.\n    /// @dev This only supports the following **standard** ERC1155 functions:\n    /// - setApprovalForAll(address,bool)\n    /// - safeTransferFrom(address,address,uint256,uint256,bytes)\n    /// - safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\n    /// @param data The calldata of the transaction.\n    /// @return The recipient of the token being sent. Zero address if the call is unsupported.\n    function getERC1155TokenRecipient(bytes memory data) internal pure returns (address) {\n        bytes4 selector = bytes4(data);\n        if (selector == IERC1155.setApprovalForAll.selector) {\n            // 68 bytes (4 selector + 32 address + 32 bool)\n            if (data.length < TRANSFER_OR_APPROVE_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector.\n            return getRecipient(data, TRANSFER_OR_APPROVE_RECIPIENT_OFFSET);\n        } else if (selector == IERC1155.safeTransferFrom.selector) {\n            // 196 bytes (4 selector + 32 address + 32 address + 32 token id + 32 amount + 32 (offset for bytes) + 32\n            // (length of bytes))\n            if (data.length < TRANSFER_FROM_WITH_BYTES_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector, and 32 for the from address.\n            return getRecipient(data, TRANSFER_FROM_RECIPIENT_OFFSET);\n        } else if (selector == IERC1155.safeBatchTransferFrom.selector) {\n            // 4 (function selector)\n            // + 64 (2 addresses, padded to 32 bytes each)\n            // + 2 * [32 (offset for each array) + 32 (length of each array) + (n * 32) (array data)]\n            // + 32 (offset for bytes) + 32 (length of bytes) + m (padded bytes data)\n            // min length 260 bytes when n == 0, m == \"\" (noop)\n            if (data.length < BATCH_TRANSFER_FROM_WITH_BYTES_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector, and 32 for the from address.\n            return getRecipient(data, TRANSFER_FROM_RECIPIENT_OFFSET);\n        }\n        return address(0);\n    }\n\n    /// @notice Decode the recipient of a token.\n    /// @dev This only supports the following **standard** ERC721 functions:\n    /// - safeTransferFrom(address,address,uint256)\n    /// - safeTransferFrom(address,address,uint256,bytes)\n    /// - transferFrom(address,address,uint256)\n    /// - approve(address,uint256)\n    /// - setApprovalForAll(address,bool)\n    /// @param data The calldata of the transaction.\n    /// @return The recipient of the token being sent. Zero address if the call is unsupported.\n    function getERC721TokenRecipient(bytes memory data) internal pure returns (address) {\n        bytes4 selector = bytes4(data);\n        if (selector == IERC721.setApprovalForAll.selector || selector == IERC721.approve.selector) {\n            // 68 bytes (4 selector + 32 address + 32 bool)\n            // or 68 bytes (4 selector + 32 address + 32 token id)\n            if (data.length < TRANSFER_OR_APPROVE_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector.\n            return getRecipient(data, TRANSFER_OR_APPROVE_RECIPIENT_OFFSET);\n        } else if (selector == ERC721_SAFE_TRANSFER_FROM || selector == IERC721.transferFrom.selector) {\n            // 100 bytes (4 selector + 32 address + 32 address + 32 token id)\n            if (data.length < TRANSFER_FROM_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector, and 32 for the from address.\n            return getRecipient(data, TRANSFER_FROM_RECIPIENT_OFFSET);\n        } else if (selector == ERC721_SAFE_TRANSFER_FROM_WITH_BYTES) {\n            // 164 bytes (4 selector + 32 address + 32 address + 32 token id + 32 (offset for bytes) + 32 (length of\n            // bytes))\n            if (data.length < TRANSFER_FROM_WITHOUT_AMOUNT_WITH_BYTES_MIN_LEN) {\n                return address(0);\n            }\n            // Jump forward: 32 for the length field, 4 for the selector, and 32 for the from address.\n            return getRecipient(data, TRANSFER_FROM_RECIPIENT_OFFSET);\n        }\n        return address(0);\n    }\n\n    /// @dev The caller must skip over the initial length prefix.\n    function getRecipient(bytes memory data, uint256 recipientIndex) private pure returns (address) {\n        address recipient;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            // Jump forward to the starting index of recipient\n            recipient := mload(add(data, recipientIndex))\n        }\n        return recipient;\n    }\n}\n"},"src/msca/6900/shared/common/Errors.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\n/**\n * @notice Throws when the caller is unexpected.\n */\nerror UnauthorizedCaller();\n\n/**\n * @notice Throws when the selector is not found.\n */\nerror NotFoundSelector();\n\n/**\n * @notice Throws when authorizer is invalid.\n */\nerror InvalidAuthorizer();\n\nerror InvalidValidationFunctionId(uint8 functionId);\n\nerror InvalidFunctionReference();\n\nerror ItemAlreadyExists();\n\nerror ItemDoesNotExist();\n\nerror InvalidLimit();\n\nerror InvalidExecutionFunction(bytes4 selector);\n\nerror InvalidInitializationInput();\n\nerror Create2FailedDeployment();\n\nerror InvalidLength();\n\nerror Unsupported();\n\nerror NotImplemented(bytes4 selector, uint8 functionId);\n\nerror InvalidItem();\n\n// v2 NotImplemented\nerror NotImplementedFunction(bytes4 selector, uint32 entityId);\n"},"src/msca/6900/v0.7/common/PluginManifest.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\n// Plugin Manifest\nenum ManifestAssociatedFunctionType {\n    // Function is not defined.\n    NONE,\n    // Function belongs to this plugin.\n    SELF,\n    // Function belongs to an external plugin provided as a dependency during plugin installation.\n    DEPENDENCY,\n    // Resolves to a magic value to always bypass runtime validation for a given function.\n    // This is only assignable on runtime validation functions. If it were to be used on a user op validation function,\n    // it would risk burning gas from the account. When used as a hook in any hook location, it is equivalent to not\n    // setting a hook and is therefore disallowed.\n    RUNTIME_VALIDATION_ALWAYS_ALLOW,\n    // Resolves to a magic value to always fail in a hook for a given function.\n    // This is only assignable to pre hooks (pre validation and pre execution). It should not be used on\n    // validation functions themselves, because this is equivalent to leaving the validation functions unset.\n    // It should not be used in post-exec hooks, because if it is known to always revert, that should happen\n    // as early as possible to save gas.\n    PRE_HOOK_ALWAYS_DENY\n}\n\n/// @dev For functions of type `ManifestAssociatedFunctionType.DEPENDENCY`, the MSCA MUST find the plugin address\n/// of the function at `dependencies[dependencyIndex]` during the call to `installPlugin(config)`.\nstruct ManifestFunction {\n    ManifestAssociatedFunctionType functionType;\n    uint8 functionId;\n    uint256 dependencyIndex;\n}\n\nstruct ManifestAssociatedFunction {\n    bytes4 executionSelector;\n    ManifestFunction associatedFunction;\n}\n\nstruct ManifestExecutionHook {\n    bytes4 selector;\n    ManifestFunction preExecHook;\n    ManifestFunction postExecHook;\n}\n\nstruct ManifestExternalCallPermission {\n    address externalAddress;\n    bool permitAnySelector;\n    bytes4[] selectors;\n}\n\nstruct SelectorPermission {\n    bytes4 functionSelector;\n    string permissionDescription;\n}\n\n/// @dev A struct holding fields to describe the plugin in a purely view context. Intended for front end clients.\nstruct PluginMetadata {\n    // A human-readable name of the plugin.\n    string name;\n    // The version of the plugin, following the semantic versioning scheme.\n    string version;\n    // The author field SHOULD be a username representing the identity of the user or organization\n    // that created this plugin.\n    string author;\n    // String descriptions of the relative sensitivity of specific functions. The selectors MUST be selectors for\n    // functions implemented by this plugin.\n    SelectorPermission[] permissionDescriptors;\n}\n\n/// @dev A struct describing how the plugin should be installed on a modular account.\nstruct PluginManifest {\n    // List of ERC-165 interface IDs to add to account to support introspection checks. This MUST NOT include\n    // IPlugin's interface ID.\n    bytes4[] interfaceIds;\n    // If this plugin depends on other plugins' validation functions, the interface IDs of those plugins MUST be\n    // provided here, with its position in the array matching the `dependencyIndex` members of `ManifestFunction`\n    bytes4[] dependencyInterfaceIds;\n    // Execution functions defined in this plugin to be installed on the MSCA.\n    bytes4[] executionFunctions;\n    // Plugin execution functions already installed on the MSCA that this plugin will be able to call.\n    bytes4[] permittedExecutionSelectors;\n    // Boolean to indicate whether the plugin can call any external address.\n    bool permitAnyExternalAddress;\n    // Boolean to indicate whether the plugin needs access to spend native tokens of the account. If false, the\n    // plugin MUST still be able to spend up to the balance that it sends to the account in the same call.\n    bool canSpendNativeToken;\n    // More granular control\n    ManifestExternalCallPermission[] permittedExternalCalls;\n    ManifestAssociatedFunction[] userOpValidationFunctions;\n    ManifestAssociatedFunction[] runtimeValidationFunctions;\n    ManifestAssociatedFunction[] preUserOpValidationHooks;\n    ManifestAssociatedFunction[] preRuntimeValidationHooks;\n    // for executionFunctions\n    ManifestExecutionHook[] executionHooks;\n}\n"},"src/msca/6900/v0.7/common/Structs.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\n// Standard executor\nstruct Call {\n    // The target address for the account to call.\n    address target;\n    // The value to send with the call.\n    uint256 value;\n    // The calldata for the call.\n    bytes data;\n}\n\nstruct FunctionReference {\n    address plugin;\n    uint8 functionId;\n}\n\n// Account loupe\n// @notice Config for an execution function, given a selector\nstruct ExecutionFunctionConfig {\n    address plugin;\n    FunctionReference userOpValidationFunction;\n    FunctionReference runtimeValidationFunction;\n}\n\n/// @notice Pre and post hooks for a given selector\n/// @dev It's possible for one of either `preExecHook` or `postExecHook` to be empty\nstruct ExecutionHooks {\n    FunctionReference preExecHook;\n    FunctionReference postExecHook;\n}\n\n// internal data structure\nstruct Bytes21DLL {\n    mapping(bytes21 => bytes21) next;\n    mapping(bytes21 => bytes21) prev;\n    uint256 count;\n}\n\nstruct RepeatableBytes21DLL {\n    mapping(bytes21 => bytes21) next;\n    mapping(bytes21 => bytes21) prev;\n    mapping(bytes21 => uint256) counter;\n    // unique items\n    uint256 uniqueItems;\n    // total items with repeatable ones\n    uint256 totalItems;\n}\n\n// Represents a set of pre and post hooks. Used to store execution hooks.\nstruct HookGroup {\n    RepeatableBytes21DLL preHooks;\n    // key = preExecHook.pack()\n    mapping(bytes21 => RepeatableBytes21DLL) preToPostHooks;\n    RepeatableBytes21DLL postOnlyHooks;\n}\n\n// plugin's permission to call external (to the account and its plugins) contracts and addresses\n// through `executeFromPluginExternal`\nstruct PermittedExternalCall {\n    bool addressPermitted;\n    // either anySelector or selectors permitted\n    bool anySelector;\n    mapping(bytes4 => bool) selectors;\n}\n\nstruct PostExecHookToRun {\n    bytes preExecHookReturnData;\n    FunctionReference postExecHook;\n}\n\n// plugin detail stored in wallet storage\nstruct PluginDetail {\n    // permitted to call any external contracts and selectors\n    bool anyExternalAddressPermitted;\n    // boolean to indicate if the plugin can spend native tokens, if any of the execution function can spend\n    // native tokens, a plugin is considered to be able to spend native tokens of the accounts\n    bool canSpendNativeToken;\n    // tracks the count this plugin has been used as a dependency function\n    uint256 dependentCounter;\n    bytes32 manifestHash;\n    Bytes21DLL dependencies;\n}\n\n// execution detail associated with selector\nstruct ExecutionDetail {\n    address plugin; // plugin address that implements the execution function, for native functions, the value should be\n        // address(0)\n    FunctionReference userOpValidationFunction;\n    RepeatableBytes21DLL preUserOpValidationHooks;\n    FunctionReference runtimeValidationFunction;\n    RepeatableBytes21DLL preRuntimeValidationHooks;\n    HookGroup executionHooks;\n}\n"},"src/msca/6900/v0.7/interfaces/IPlugin.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\nimport \"../common/PluginManifest.sol\";\nimport \"../common/Structs.sol\";\nimport {PackedUserOperation} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\n\n/**\n * @dev Implements https://eips.ethereum.org/EIPS/eip-6900. Plugins must implement this interface to support plugin\n * management and interactions with MSCAs.\n */\ninterface IPlugin {\n    /// @notice Initialize plugin data for the modular account.\n    /// @dev Called by the modular account during `installPlugin`.\n    /// @param data Optional bytes array to be decoded and used by the plugin to setup initial plugin data for the\n    /// modular account.\n    function onInstall(bytes calldata data) external;\n\n    /// @notice Clear plugin data for the modular account.\n    /// @dev Called by the modular account during `uninstallPlugin`.\n    /// @param data Optional bytes array to be decoded and used by the plugin to clear plugin data for the modular\n    /// account.\n    function onUninstall(bytes calldata data) external;\n\n    /// @notice Run the pre user operation validation hook specified by the `functionId`.\n    /// @dev Pre user operation validation hooks MUST NOT return an authorizer value other than 0 or 1.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param userOp The user operation.\n    /// @param userOpHash The user operation hash.\n    /// @return Packed validation data for validAfter (6 bytes), validUntil (6 bytes), and authorizer (20 bytes).\n    function preUserOpValidationHook(uint8 functionId, PackedUserOperation calldata userOp, bytes32 userOpHash)\n        external\n        returns (uint256);\n\n    /// @notice Run the user operation validationFunction specified by the `functionId`.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be\n    /// more than one.\n    /// @param userOp The user operation.\n    /// @param userOpHash The user operation hash.\n    /// @return Packed validation data for validAfter (6 bytes), validUntil (6 bytes), and authorizer (20 bytes).\n    function userOpValidationFunction(uint8 functionId, PackedUserOperation calldata userOp, bytes32 userOpHash)\n        external\n        returns (uint256);\n\n    /// @notice Run the pre runtime validation hook specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param sender The caller address.\n    /// @param value The call value.\n    /// @param data The calldata sent.\n    function preRuntimeValidationHook(uint8 functionId, address sender, uint256 value, bytes calldata data) external;\n\n    /// @notice Run the runtime validationFunction specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be\n    /// more than one.\n    /// @param sender The caller address.\n    /// @param value The call value.\n    /// @param data The calldata sent.\n    function runtimeValidationFunction(uint8 functionId, address sender, uint256 value, bytes calldata data) external;\n\n    /// @notice Run the pre execution hook specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param sender The caller address.\n    /// @param value The call value.\n    /// @param data The calldata sent.\n    /// @return context Context to pass to a post execution hook, if present. An empty bytes array MAY be returned.\n    function preExecutionHook(uint8 functionId, address sender, uint256 value, bytes calldata data)\n        external\n        returns (bytes memory context);\n\n    /// @notice Run the post execution hook specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param preExecHookData The context returned by its associated pre execution hook.\n    function postExecutionHook(uint8 functionId, bytes calldata preExecHookData) external;\n\n    /// @notice Describe the contents and intended configuration of the plugin.\n    /// @dev This manifest MUST stay constant over time.\n    /// @return A manifest describing the contents and intended configuration of the plugin.\n    function pluginManifest() external pure returns (PluginManifest memory);\n\n    /// @notice Describe the metadata of the plugin.\n    /// @dev This metadata MUST stay constant over time.\n    /// @return A metadata struct describing the plugin.\n    function pluginMetadata() external pure returns (PluginMetadata memory);\n}\n"},"src/msca/6900/v0.7/interfaces/IStandardExecutor.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\nimport \"../common/Structs.sol\";\n\n/**\n * @dev Implements https://eips.ethereum.org/EIPS/eip-6900. MSCAs must implement this interface to support open-ended\n * execution.\n */\ninterface IStandardExecutor {\n    /// @notice Standard execute method.\n    /// @dev If the target is a plugin, the call SHOULD revert.\n    /// @param target The target address for the account to call.\n    /// @param value The value to send with the call.\n    /// @param data The calldata for the call.\n    /// @return The return data from the call.\n    function execute(address target, uint256 value, bytes calldata data) external payable returns (bytes memory);\n\n    /// @notice Standard executeBatch method.\n    /// @dev If the target is a plugin, the call SHOULD revert. If any of the calls revert, the entire batch MUST\n    /// revert.\n    /// @param calls The array of calls.\n    /// @return An array containing the return data from the calls.\n    function executeBatch(Call[] calldata calls) external payable returns (bytes[] memory);\n}\n"},"src/msca/6900/v0.7/plugins/BasePlugin.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\nimport {NotImplemented} from \"../../shared/common/Errors.sol\";\nimport \"../common/PluginManifest.sol\";\nimport \"../common/Structs.sol\";\nimport {IPlugin} from \"../interfaces/IPlugin.sol\";\nimport {PackedUserOperation} from \"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Default implementation of https://eips.ethereum.org/EIPS/eip-6900. MSCAs must implement this interface to\n * support open-ended execution.\n */\nabstract contract BasePlugin is IPlugin, ERC165 {\n    error AlreadyInitialized();\n    error NotInitialized();\n\n    /// @dev Ensure the account has initialized this plugin\n    /// @param account the account to check\n    modifier isNotInitialized(address account) {\n        if (_isInitialized(account)) {\n            revert AlreadyInitialized();\n        }\n        _;\n    }\n\n    /// @dev Ensure the account has not initialized this plugin\n    /// @param account the account to check\n    modifier isInitialized(address account) {\n        if (!_isInitialized(account)) {\n            revert NotInitialized();\n        }\n        _;\n    }\n\n    /// @notice Initialize plugin data for the modular account.\n    /// @dev Called by the modular account during `installPlugin`.\n    /// @param data Optional bytes array to be decoded and used by the plugin to setup initial plugin data for the\n    /// modular account.\n    function onInstall(bytes calldata data) external virtual {\n        (data);\n        revert NotImplemented(msg.sig, 0);\n    }\n\n    /// @notice Clear plugin data for the modular account.\n    /// @dev Called by the modular account during `uninstallPlugin`.\n    /// @param data Optional bytes array to be decoded and used by the plugin to clear plugin data for the modular\n    /// account.\n    function onUninstall(bytes calldata data) external virtual {\n        (data);\n        revert NotImplemented(msg.sig, 0);\n    }\n\n    /// @notice Run the pre user operation validation hook specified by the `functionId`.\n    /// @dev Pre user operation validation hooks MUST NOT return an authorizer value other than 0 or 1.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param userOp The user operation.\n    /// @param userOpHash The user operation hash.\n    /// @return validationData Packed validation data for validAfter (6 bytes), validUntil (6 bytes), and authorizer (20\n    /// bytes).\n    function preUserOpValidationHook(uint8 functionId, PackedUserOperation calldata userOp, bytes32 userOpHash)\n        external\n        virtual\n        returns (uint256 validationData)\n    {\n        (functionId, userOp, userOpHash);\n        revert NotImplemented(msg.sig, functionId);\n    }\n\n    /// @notice Run the user operation validationFunction specified by the `functionId`.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be\n    /// more than one.\n    /// @param userOp The user operation.\n    /// @param userOpHash The user operation hash.\n    /// @return validationData Packed validation data for validAfter (6 bytes), validUntil (6 bytes), and authorizer (20\n    /// bytes).\n    function userOpValidationFunction(uint8 functionId, PackedUserOperation calldata userOp, bytes32 userOpHash)\n        external\n        virtual\n        returns (uint256 validationData)\n    {\n        (functionId, userOp, userOpHash);\n        revert NotImplemented(msg.sig, functionId);\n    }\n\n    /// @notice Run the pre runtime validation hook specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param sender The caller address.\n    /// @param value The call value.\n    /// @param data The calldata sent.\n    function preRuntimeValidationHook(uint8 functionId, address sender, uint256 value, bytes calldata data)\n        external\n        virtual\n    {\n        (functionId, sender, value, data);\n        revert NotImplemented(msg.sig, functionId);\n    }\n\n    /// @notice Run the runtime validationFunction specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be\n    /// more than one.\n    /// @param sender The caller address.\n    /// @param value The call value.\n    /// @param data The calldata sent.\n    function runtimeValidationFunction(uint8 functionId, address sender, uint256 value, bytes calldata data)\n        external\n        virtual\n    {\n        (functionId, sender, value, data);\n        revert NotImplemented(msg.sig, functionId);\n    }\n\n    /// @notice Run the pre execution hook specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param sender The caller address.\n    /// @param value The call value.\n    /// @param data The calldata sent.\n    /// @return context Context to pass to a post execution hook, if present. An empty bytes array MAY be returned.\n    function preExecutionHook(uint8 functionId, address sender, uint256 value, bytes calldata data)\n        external\n        virtual\n        returns (bytes memory context)\n    {\n        (functionId, sender, value, data);\n        revert NotImplemented(msg.sig, functionId);\n    }\n\n    /// @notice Run the post execution hook specified by the `functionId`.\n    /// @dev To indicate the entire call should revert, the function MUST revert.\n    /// @param functionId An identifier that routes the call to different internal implementations, should there be more\n    /// than one.\n    /// @param preExecHookData The context returned by its associated pre execution hook.\n    function postExecutionHook(uint8 functionId, bytes calldata preExecHookData) external virtual {\n        (functionId, preExecHookData);\n        revert NotImplemented(msg.sig, functionId);\n    }\n\n    /// @notice Describe the contents and intended configuration of the plugin.\n    /// @dev The manifest MUST stay constant over time.\n    /// @return A manifest describing the contents and intended configuration of the plugin.\n    function pluginManifest() external pure virtual returns (PluginManifest memory) {\n        revert NotImplemented(msg.sig, 0);\n    }\n\n    /// @notice Describe the metadata of the plugin.\n    /// @dev This metadata MUST stay constant over time.\n    /// @return A metadata struct describing the plugin.\n    function pluginMetadata() external pure virtual returns (PluginMetadata memory) {\n        revert NotImplemented(msg.sig, 0);\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by\n    /// `interfaceId`. See the corresponding\n    /// https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    /// to learn more about how these ids are created.\n    ///\n    /// This function call must use less than 30,000 gas.\n    ///\n    /// Supporting the IPlugin interface is a requirement for plugin installation (PluginManager). This is also used\n    /// by the modular account to prevent StandardExecutor functions from making calls to plugins.\n    /// @param interfaceId The interface ID to check for support.\n    /// @return True if the contract supports `interfaceId`.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IPlugin).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @notice Check if the account has initialized this plugin yet\n    /// @dev This function should be overwritten for plugins that have state-changing onInstall's\n    /// @param account The account to check\n    /// @return True if the account has initialized this plugin\n    // solhint-disable-next-line no-empty-blocks\n    function _isInitialized(address account) internal view virtual returns (bool) {\n        (account);\n        revert NotImplemented(msg.sig, 0);\n    }\n}\n"},"src/msca/6900/v0.7/plugins/v1_0_0/addressbook/IAddressBookPlugin.sol":{"content":"/*\n * Copyright 2024 Circle Internet Group, Inc. All rights reserved.\n\n * SPDX-License-Identifier: GPL-3.0-or-later\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\npragma solidity 0.8.24;\n\n/**\n * @dev Interface for address book plugin.\n *      This plugin allows MSCA to check if the destination address is allowed to receive assets like native token,\n * ERC20 tokens, etc.\n *      The implementation could store an internal allowedRecipients that implements associated storage linked list\n *      because bundler validation rules only allow the entity to access the sender associated storage.\n *      By default the recipient is allowed to accept any tokens if it's added to the address book.\n */\ninterface IAddressBookPlugin {\n    event AllowedAddressesAdded(address indexed account, address[] recipients);\n    event AllowedAddressesRemoved(address indexed account, address[] recipients);\n    event AllowedAddressesNotRemoved(address indexed account);\n\n    error FailToAddRecipient(address account, address recipient);\n    error FailToRemoveRecipient(address account, address recipient);\n    error UnauthorizedRecipient(address account, address recipient);\n    error CallDataIsNotEmpty(address account, address target, uint256 value, bytes data);\n    error InvalidTargetCodeLength(address account, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Add allowed recipients. By default the recipient is allowed to accept all tokens.\n     * Can only be called by the current msg.sender.\n     */\n    function addAllowedRecipients(address[] calldata recipients) external;\n\n    /**\n     * @dev Remove allowed recipients.\n     * Can only be called by the current msg.sender.\n     */\n    function removeAllowedRecipients(address[] calldata recipients) external;\n\n    /**\n     * @dev Returns the allowed addresses of the current MSCA.\n     */\n    function getAllowedRecipients(address account) external view returns (address[] memory);\n}\n"},"lib/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"lib/modular-account-libs/src/libraries/AssociatedLinkedListSetLib.sol":{"content":"// SPDX-License-Identifier: MIT\n//\n// See LICENSE-MIT file for more information\n\npragma solidity ^0.8.20;\n\nimport {SetValue, SENTINEL_VALUE, HAS_NEXT_FLAG} from \"./Constants.sol\";\n\n/// @dev Type representing the set, which is just a storage slot placeholder like the solidity mapping type.\nstruct AssociatedLinkedListSet {\n    bytes32 placeholder;\n}\n\n/// @title Associated Linked List Set Library\n/// @notice Provides a set data structure that is enumerable and held in address-associated storage (per the\n/// ERC-4337 spec)\nlibrary AssociatedLinkedListSetLib {\n    // Mapping Entry Byte Layout\n    // | value | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA____ |\n    // | meta  | 0x____________________________________________________________BBBB |\n\n    // Bit-layout of the meta bytes (2 bytes)\n    // | user flags | 11111111 11111100 |\n    // | has next   | 00000000 00000010 |\n    // | sentinel   | 00000000 00000001 |\n\n    // Mapping keys exclude the upper 15 bits of the meta bytes, which allows keys to be either a value or the\n    // sentinel.\n\n    // This cannot be evaluated at compile time because of its use in inline assembly.\n    bytes4 internal constant ASSOCIATED_STORAGE_PREFIX = 0xf938c976; // bytes4(keccak256(\"AssociatedLinkedListSet\"))\n\n    // A custom type representing the index of a storage slot\n    type StoragePointer is bytes32;\n\n    // A custom type representing a pointer to a location in memory beyond the current free memory pointer.\n    // Holds a fixed-size buffer similar to \"bytes memory\", but without a length field.\n    // Care must be taken when using these, as they may be overwritten if ANY memory is allocated after allocating\n    // a TempBytesMemory.\n    type TempBytesMemory is bytes32;\n\n    // INTERNAL METHODS\n\n    /// @notice Adds a value to a set.\n    /// @param set The set to add the value to.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to add.\n    /// @return True if the value was added, false if the value cannot be added (already exists or is zero).\n    function tryAdd(AssociatedLinkedListSet storage set, address associated, SetValue value) internal returns (bool) {\n        bytes32 unwrappedKey = bytes32(SetValue.unwrap(value));\n        if (unwrappedKey == bytes32(0)) {\n            // Cannot add the zero value\n            return false;\n        }\n\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        StoragePointer valueSlot = _mapLookup(keyBuffer, unwrappedKey);\n        if (_load(valueSlot) != bytes32(0)) {\n            // Entry already exists\n            return false;\n        }\n\n        // Load the head of the set\n        StoragePointer sentinelSlot = _mapLookup(keyBuffer, SENTINEL_VALUE);\n        bytes32 prev = _load(sentinelSlot);\n        if (prev == bytes32(0) || isSentinel(prev)) {\n            // set is empty, need to do:\n            // map[SENTINEL_VALUE] = unwrappedKey;\n            // map[unwrappedKey] = SENTINEL_VALUE;\n            _store(sentinelSlot, unwrappedKey);\n            _store(valueSlot, SENTINEL_VALUE);\n        } else {\n            // set is not empty, need to do:\n            // map[SENTINEL_VALUE] = unwrappedKey | HAS_NEXT_FLAG;\n            // map[unwrappedKey] = prev;\n            _store(sentinelSlot, unwrappedKey | HAS_NEXT_FLAG);\n            _store(valueSlot, prev);\n        }\n\n        return true;\n    }\n\n    /// @notice Removes a value from a set.\n    /// @dev This is an O(n) operation, where n is the number of elements in the set.\n    /// @param set The set to remove the value from\n    /// @param associated The address the set is associated with\n    /// @param value The value to remove\n    /// @return True if the value was removed, false if the value does not exist\n    function tryRemove(AssociatedLinkedListSet storage set, address associated, SetValue value)\n        internal\n        returns (bool)\n    {\n        bytes32 unwrappedKey = bytes32(SetValue.unwrap(value));\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        StoragePointer valueSlot = _mapLookup(keyBuffer, unwrappedKey);\n        bytes32 nextValue = _load(valueSlot);\n        if (unwrappedKey == bytes32(0) || nextValue == bytes32(0)) {\n            // Entry does not exist\n            return false;\n        }\n\n        bytes32 prevKey = SENTINEL_VALUE;\n        bytes32 currentVal;\n        do {\n            // Load the current entry\n            StoragePointer prevSlot = _mapLookup(keyBuffer, prevKey);\n            currentVal = _load(prevSlot);\n            bytes32 currentKey = clearFlags(currentVal);\n            if (currentKey == unwrappedKey) {\n                // Found the entry\n                // Set the previous value's next value to the next value,\n                // and the flags to the current value's flags.\n                // and the next value's `hasNext` flag to determine whether or not the next value is (or points to)\n                // the sentinel value.\n\n                // Need to do:\n                // map[prevKey] = clearFlags(nextValue) | getUserFlags(currentVal) | (nextValue & HAS_NEXT_FLAG);\n                // map[currentKey] = bytes32(0);\n\n                _store(prevSlot, clearFlags(nextValue) | getUserFlags(currentVal) | (nextValue & HAS_NEXT_FLAG));\n                _store(valueSlot, bytes32(0));\n\n                return true;\n            }\n            prevKey = currentKey;\n        } while (!isSentinel(currentVal) && currentVal != bytes32(0));\n        return false;\n    }\n\n    /// @notice Removes a value from a set, given the previous value in the set.\n    /// @dev This is an O(1) operation but requires additional knowledge.\n    /// @param set The set to remove the value from\n    /// @param associated The address the set is associated with\n    /// @param value The value to remove\n    /// @param prev The previous value in the set\n    /// @return True if the value was removed, false if the value does not exist\n    function tryRemoveKnown(AssociatedLinkedListSet storage set, address associated, SetValue value, bytes32 prev)\n        internal\n        returns (bool)\n    {\n        bytes32 unwrappedKey = bytes32(SetValue.unwrap(value));\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        prev = clearFlags(prev);\n\n        if (prev == bytes32(0) || unwrappedKey == bytes32(0)) {\n            return false;\n        }\n\n        // assert that the previous key's next value is the value to be removed\n        StoragePointer prevSlot = _mapLookup(keyBuffer, prev);\n        bytes32 currentValue = _load(prevSlot);\n        if (clearFlags(currentValue) != unwrappedKey) {\n            return false;\n        }\n\n        StoragePointer valueSlot = _mapLookup(keyBuffer, unwrappedKey);\n        bytes32 next = _load(valueSlot);\n        if (next == bytes32(0)) {\n            // The set didn't actually contain the value\n            return false;\n        }\n\n        // Need to do:\n        // map[prev] = clearUserFlags(next) | getUserFlags(currentValue);\n        // map[unwrappedKey] = bytes32(0);\n        _store(prevSlot, clearUserFlags(next) | getUserFlags(currentValue));\n        _store(valueSlot, bytes32(0));\n\n        return true;\n    }\n\n    /// @notice Removes all values from a set.\n    /// @dev This is an O(n) operation, where n is the number of elements in the set.\n    /// @param set The set to remove the values from\n    /// @param associated The address the set is associated with\n    function clear(AssociatedLinkedListSet storage set, address associated) internal {\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        bytes32 cursor = SENTINEL_VALUE;\n\n        do {\n            StoragePointer cursorSlot = _mapLookup(keyBuffer, cursor);\n            bytes32 next = clearFlags(_load(cursorSlot));\n            _store(cursorSlot, bytes32(0));\n            cursor = next;\n        } while (!isSentinel(cursor) && cursor != bytes32(0));\n    }\n\n    /// @notice Set the flags on a value in the set.\n    /// @dev The user flags can only be set on the upper 14 bits, because the lower two are reserved for the\n    /// sentinel and has next bit.\n    /// @param set The set containing the value.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to set the flags on.\n    /// @param flags The flags to set.\n    /// @return True if the set contains the value and the operation succeeds, false otherwise.\n    function trySetFlags(AssociatedLinkedListSet storage set, address associated, SetValue value, uint16 flags)\n        internal\n        returns (bool)\n    {\n        bytes32 unwrappedKey = SetValue.unwrap(value);\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        // Ignore the lower 2 bits.\n        flags &= 0xFFFC;\n\n        // If the set doesn't actually contain the value, return false;\n        StoragePointer valueSlot = _mapLookup(keyBuffer, unwrappedKey);\n        bytes32 next = _load(valueSlot);\n        if (next == bytes32(0)) {\n            return false;\n        }\n\n        // Set the flags\n        _store(valueSlot, clearUserFlags(next) | bytes32(uint256(flags)));\n\n        return true;\n    }\n\n    /// @notice Set the given flags on a value in the set, preserving the values of other flags.\n    /// @dev The user flags can only be set on the upper 14 bits, because the lower two are reserved for the\n    /// sentinel and has next bit.\n    /// Short-circuits if the flags are already enabled, returning true.\n    /// @param set The set containing the value.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to enable the flags on.\n    /// @param flags The flags to enable.\n    /// @return True if the operation succeeds or short-circuits due to the flags already being enabled. False\n    /// otherwise.\n    function tryEnableFlags(AssociatedLinkedListSet storage set, address associated, SetValue value, uint16 flags)\n        internal\n        returns (bool)\n    {\n        flags &= 0xFFFC; // Allow short-circuit if lower bits are accidentally set\n        uint16 currFlags = getFlags(set, associated, value);\n        if (currFlags & flags == flags) return true; // flags are already enabled\n        return trySetFlags(set, associated, value, currFlags | flags);\n    }\n\n    /// @notice Clear the given flags on a value in the set, preserving the values of other flags.\n    /// @notice If the value is not in the set, this function will still return true.\n    /// @dev The user flags can only be set on the upper 14 bits, because the lower two are reserved for the\n    /// sentinel and has next bit.\n    /// Short-circuits if the flags are already disabled, or if set does not contain the value. Short-circuits\n    /// return true.\n    /// @param set The set containing the value.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to disable the flags on.\n    /// @param flags The flags to disable.\n    /// @return True if the operation succeeds, or short-circuits due to the flags already being disabled or if the\n    /// set does not contain the value. False otherwise.\n    function tryDisableFlags(AssociatedLinkedListSet storage set, address associated, SetValue value, uint16 flags)\n        internal\n        returns (bool)\n    {\n        flags &= 0xFFFC; // Allow short-circuit if lower bits are accidentally set\n        uint16 currFlags = getFlags(set, associated, value);\n        if (currFlags & flags == 0) return true; // flags are already disabled\n        return trySetFlags(set, associated, value, currFlags & ~flags);\n    }\n\n    /// @notice Checks if a set contains a value\n    /// @dev This method does not clear the upper bits of `value`, that is expected to be done as part of casting\n    /// to the correct type. If this function is provided the sentinel value by using the upper bits, this function\n    /// may returns `true`.\n    /// @param set The set to check\n    /// @param associated The address the set is associated with\n    /// @param value The value to check for\n    /// @return True if the set contains the value, false otherwise\n    function contains(AssociatedLinkedListSet storage set, address associated, SetValue value)\n        internal\n        view\n        returns (bool)\n    {\n        bytes32 unwrappedKey = bytes32(SetValue.unwrap(value));\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        StoragePointer slot = _mapLookup(keyBuffer, unwrappedKey);\n        return _load(slot) != bytes32(0);\n    }\n\n    /// @notice Checks if a set is empty\n    /// @param set The set to check\n    /// @param associated The address the set is associated with\n    /// @return True if the set is empty, false otherwise\n    function isEmpty(AssociatedLinkedListSet storage set, address associated) internal view returns (bool) {\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n\n        StoragePointer sentinelSlot = _mapLookup(keyBuffer, SENTINEL_VALUE);\n        bytes32 val = _load(sentinelSlot);\n        return val == bytes32(0) || isSentinel(val); // either the sentinel is unset, or points to itself\n    }\n\n    /// @notice Get the flags on a value in the set.\n    /// @dev The reserved lower 2 bits will not be returned, as those are reserved for the sentinel and has next\n    /// bit.\n    /// @param set The set containing the value.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to get the flags from.\n    /// @return The flags set on the value.\n    function getFlags(AssociatedLinkedListSet storage set, address associated, SetValue value)\n        internal\n        view\n        returns (uint16)\n    {\n        bytes32 unwrappedKey = SetValue.unwrap(value);\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n        return uint16(uint256(_load(_mapLookup(keyBuffer, unwrappedKey))) & 0xFFFC);\n    }\n\n    /// @notice Check if the flags on a value are enabled.\n    /// @dev The reserved lower 2 bits will be ignored, as those are reserved for the sentinel and has next bit.\n    /// @param set The set containing the value.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to check the flags on.\n    /// @param flags The flags to check.\n    /// @return True if all of the flags are enabled, false otherwise.\n    function flagsEnabled(AssociatedLinkedListSet storage set, address associated, SetValue value, uint16 flags)\n        internal\n        view\n        returns (bool)\n    {\n        flags &= 0xFFFC;\n        return getFlags(set, associated, value) & flags == flags;\n    }\n\n    /// @notice Check if the flags on a value are disabled.\n    /// @dev The reserved lower 2 bits will be ignored, as those are reserved for the sentinel and has next bit.\n    /// @param set The set containing the value.\n    /// @param associated The address the set is associated with.\n    /// @param value The value to check the flags on.\n    /// @param flags The flags to check.\n    /// @return True if all of the flags are disabled, false otherwise.\n    function flagsDisabled(AssociatedLinkedListSet storage set, address associated, SetValue value, uint16 flags)\n        internal\n        view\n        returns (bool)\n    {\n        flags &= 0xFFFC;\n        return ~(getFlags(set, associated, value)) & flags == flags;\n    }\n\n    /// @notice Gets all elements in a set.\n    /// @dev This is an O(n) operation, where n is the number of elements in the set.\n    /// @param set The set to get the elements of.\n    /// @return ret An array of all elements in the set.\n    function getAll(AssociatedLinkedListSet storage set, address associated)\n        internal\n        view\n        returns (SetValue[] memory ret)\n    {\n        TempBytesMemory keyBuffer = _allocateTempKeyBuffer(set, associated);\n        uint256 size;\n        bytes32 cursor = _load(_mapLookup(keyBuffer, SENTINEL_VALUE));\n\n        // Dynamically allocate the returned array as we iterate through the set, since we don't know the size\n        // beforehand.\n        // This is accomplished by first writing to memory after the free memory pointer,\n        // then updating the free memory pointer to cover the newly-allocated data.\n        // To the compiler, writes to memory after the free memory pointer are considered \"memory safe\".\n        // See https://docs.soliditylang.org/en/v0.8.22/assembly.html#memory-safety\n        // Stack variable lifting done when compiling with via-ir will only ever place variables into memory\n        // locations below the current free memory pointer, so it is safe to compile this library with via-ir.\n        // See https://docs.soliditylang.org/en/v0.8.22/yul.html#memoryguard\n        /// @solidity memory-safe-assembly\n        assembly {\n            // It is critical that no other memory allocations occur between:\n            // -  loading the value of the free memory pointer into `ret`\n            // -  updating the free memory pointer to point to the newly-allocated data, which is done after all\n            // the values have been written.\n            ret := mload(0x40)\n            // Add an extra offset of 4 words to account for the length of the keyBuffer, since it will be used\n            // for each lookup. If this value were written back to the free memory pointer, it would effectively\n            // convert the keyBuffer into a \"bytes memory\" type. However, we don't actually write to the free\n            // memory pointer until after all we've also allocated the entire return array.\n            ret := add(ret, 0x80)\n        }\n\n        while (!isSentinel(cursor) && cursor != bytes32(0)) {\n            unchecked {\n                ++size;\n            }\n            bytes32 cleared = clearFlags(cursor);\n            // Place the item into the return array manually. Since the size was just incremented, it will point to\n            // the next location to write to.\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(ret, mul(size, 0x20)), cleared)\n            }\n            if (hasNext(cursor)) {\n                cursor = _load(_mapLookup(keyBuffer, cleared));\n            } else {\n                cursor = bytes32(0);\n            }\n        }\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Update the free memory pointer with the now-known length of the array.\n            mstore(0x40, add(ret, mul(add(size, 1), 0x20)))\n            // Set the length of the array.\n            mstore(ret, size)\n        }\n    }\n\n    function isSentinel(bytes32 value) internal pure returns (bool ret) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ret := and(value, 1)\n        }\n    }\n\n    function hasNext(bytes32 value) internal pure returns (bool) {\n        return value & HAS_NEXT_FLAG != 0;\n    }\n\n    function clearFlags(bytes32 val) internal pure returns (bytes32) {\n        return val & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001;\n    }\n\n    /// @dev Preserves the lower two bits\n    function clearUserFlags(bytes32 val) internal pure returns (bytes32) {\n        return val & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0003;\n    }\n\n    function getUserFlags(bytes32 val) internal pure returns (bytes32) {\n        return val & bytes32(uint256(0xFFFC));\n    }\n\n    // PRIVATE METHODS\n\n    /// @notice Given an allocated key buffer, returns the storage slot for a given key\n    function _mapLookup(TempBytesMemory keyBuffer, bytes32 value) private pure returns (StoragePointer slot) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the value in the last word.\n            mstore(add(keyBuffer, 0x60), value)\n            slot := keccak256(keyBuffer, 0x80)\n        }\n    }\n\n    /// @notice Allocates a key buffer for a given ID and associated address into scratch space memory.\n    /// @dev The returned buffer must not be used if any additional memory is allocated after calling this\n    /// function.\n    /// @param set The set to allocate the key buffer for.\n    /// @param associated The address the set is associated with.\n    /// @return key A key buffer that can be used to lookup values in the set\n    function _allocateTempKeyBuffer(AssociatedLinkedListSet storage set, address associated)\n        private\n        pure\n        returns (TempBytesMemory key)\n    {\n        // Key derivation for an entry\n        // Note: `||` refers to the concat operator\n        // associated addr (left-padded) || prefix || uint224(0) batchIndex || set storage slot || entry\n        // Word 1:\n        // | zeros              | 0x000000000000000000000000________________________________________ |\n        // | address            | 0x________________________AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA |\n        // Word 2:\n        // | prefix             | 0xPPPPPPPP________________________________________________________ |\n        // | batch index (zero) | 0x________00000000000000000000000000000000000000000000000000000000 |\n        // Word 3:\n        // | set storage slot  | 0xSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS |\n        // Word 4:\n        // | entry value        | 0xVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV____ |\n        // | entry meta         | 0x____________________________________________________________MMMM |\n\n        // The batch index is for consistency with PluginStorageLib, and the prefix in front of it is\n        // to prevent any potential crafted collisions where the batch index may be equal to storage slot\n        // of the ALLS. The prefix is set to the upper bits of the batch index to make it infeasible to\n        // reach from just incrementing the value.\n\n        // This segment is memory-safe because it only uses the scratch space memory after the value of the free\n        // memory pointer.\n        // See https://docs.soliditylang.org/en/v0.8.22/assembly.html#memory-safety\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean upper bits of arguments\n            associated := and(associated, 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // Use memory past-the-free-memory-pointer without updating it, as this is just scratch space\n            key := mload(0x40)\n            // Store the associated address in the first word, left-padded with zeroes\n            mstore(key, associated)\n            // Store the prefix and a batch index of 0\n            mstore(add(key, 0x20), ASSOCIATED_STORAGE_PREFIX)\n            // Store the list's storage slot in the third word\n            mstore(add(key, 0x40), set.slot)\n            // Leaves the last word open for the value entry\n        }\n\n        return key;\n    }\n\n    /// @dev Loads a value from storage\n    function _load(StoragePointer ptr) private view returns (bytes32 val) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            val := sload(ptr)\n        }\n    }\n\n    /// @dev Writes a value into storage\n    function _store(StoragePointer ptr, bytes32 val) private {\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr, val)\n        }\n    }\n}\n"},"lib/modular-account-libs/src/libraries/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\n//\n// See LICENSE-MIT file for more information\n\npragma solidity ^0.8.20;\n\ntype SetValue is bytes30;\n\n/// @dev The sentinel value is used to indicate the head and tail of the list.\nbytes32 constant SENTINEL_VALUE = bytes32(uint256(1));\n\n/// @dev Removing the last element will result in this flag not being set correctly, but all operations will\n/// function normally, albeit with one extra sload for getAll.\nbytes32 constant HAS_NEXT_FLAG = bytes32(uint256(2));\n\n/// @dev As defined by ERC-4337.\nuint256 constant SIG_VALIDATION_PASSED = 0;\nuint256 constant SIG_VALIDATION_FAILED = 1;\n"},"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}},"settings":{"remappings":["@account-abstraction/=lib/account-abstraction/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","eth-gas-reporter/=node_modules/eth-gas-reporter/","forge-std/=lib/forge-std/","hardhat/=node_modules/hardhat/","@modular-account/=lib/modular-account/src/","@solady/=lib/solady/src/","@fcl/=lib/FreshCryptoLib/solidity/src/","@p256-verifier/=lib/p256-verifier/src/","@webauthn-sol/=lib/webauthn-sol/src/","@modular-account-libs/=lib/modular-account-libs/src/","FreshCryptoLib/=lib/FreshCryptoLib/solidity/src/","account-abstraction/=lib/account-abstraction/contracts/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","modular-account-libs/=lib/modular-account-libs/src/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","p256-verifier/=lib/p256-verifier/","solady/=lib/solady/src/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
